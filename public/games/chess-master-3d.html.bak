<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Master 3D - ASHURA Games</title>
    <!-- ASHURA:shared-css -->
    <link rel="stylesheet" href="./game-enhancement.css">
    <link rel="stylesheet" href="./game-optimization.css">
    <link rel="stylesheet" href="./_assets/game-frame.css">

    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #f39c12;
            box-shadow: 0 0 30px rgba(243,156,18,0.4);
        }
        canvas {
            border: 3px solid #f39c12;
            background: linear-gradient(45deg, #8B4513 0%, #D2B48C 25%, #8B4513 25%, #8B4513 50%, #D2B48C 50%, #D2B48C 75%, #8B4513 75%);
            background-size: 80px 80px;
            border-radius: 10px;
            cursor: pointer;
        }
        .ui-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 16px;
            color: #f39c12;
        }
        .turn-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(243,156,18,0.2);
            border: 1px solid #f39c12;
            margin: 10px auto;
            width: fit-content;
        }
        .controls {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.8;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(243,156,18,0.5);
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #f39c12;
            display: none;
            z-index: 10;
        }
        .captured-pieces {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui-bar">
            <div>ผู้เล่น (ขาว)</div>
            <div>AI (ดำ)</div>
        </div>
        <div class="captured-pieces">
            <div>จับได้: <span id="whiteCaptured"></span></div>
            <div>จับได้: <span id="blackCaptured"></span></div>
        </div>
        <canvas id="gameCanvas" width="640" height="640"></canvas>
        <div class="turn-indicator" id="turnIndicator">ตาของคุณ (ขาว)</div>
        <div style="margin: 15px 0;">
            <button onclick="newGame()">เกมใหม่</button>
            <button onclick="undoMove()">ย้อนกลับ</button>
            <button onclick="toggleDifficulty()" id="difficultyBtn">ง่าย</button>
        </div>
        <div class="controls">
            คลิกชิ้นหมากเพื่อเลือก แล้วคลิกตำแหน่งเป้าหมาย • ลากชิ้นหมากก็ได้
        </div>
        <div class="game-over" id="gameOver">
            <h2 id="gameResult">เกมจบ!</h2>
            <p id="gameMessage"></p>
            <button onclick="newGame()">เล่นใหม่</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const BOARD_SIZE = 8;
        const SQUARE_SIZE = 80;
        
        let board = [];
        let selectedPiece = null;
        let currentPlayer = 'white';
        let gameRunning = true;
        let difficulty = 'easy';
        let moveHistory = [];
        let capturedWhite = [];
        let capturedBlack = [];
        
        // Unicode chess pieces
        const pieces = {
            'white': {
                'king': '♔', 'queen': '♕', 'rook': '♖', 
                'bishop': '♗', 'knight': '♘', 'pawn': '♙'
            },
            'black': {
                'king': '♚', 'queen': '♛', 'rook': '♜', 
                'bishop': '♝', 'knight': '♞', 'pawn': '♟'
            }
        };
        
        function initBoard() {
            board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pieces
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            
            for (let i = 0; i < 8; i++) {
                board[0][i] = { type: backRow[i], color: 'black', moved: false };
                board[1][i] = { type: 'pawn', color: 'black', moved: false };
                board[6][i] = { type: 'pawn', color: 'white', moved: false };
                board[7][i] = { type: backRow[i], color: 'white', moved: false };
            }
            
            selectedPiece = null;
            currentPlayer = 'white';
            gameRunning = true;
            moveHistory = [];
            capturedWhite = [];
            capturedBlack = [];
            updateDisplay();
        }
        
        function drawBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const x = col * SQUARE_SIZE;
                    const y = row * SQUARE_SIZE;
                    
                    // Square colors
                    ctx.fillStyle = (row + col) % 2 === 0 ? '#F0D9B5' : '#B58863';
                    ctx.fillRect(x, y, SQUARE_SIZE, SQUARE_SIZE);
                    
                    // Highlight selected piece
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                        ctx.fillRect(x, y, SQUARE_SIZE, SQUARE_SIZE);
                    }
                    
                    // Highlight valid moves
                    if (selectedPiece) {
                        const validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                        if (validMoves.some(move => move.row === row && move.col === col)) {
                            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                            ctx.fillRect(x, y, SQUARE_SIZE, SQUARE_SIZE);
                        }
                    }
                    
                    // Draw piece
                    const piece = board[row][col];
                    if (piece) {
                        ctx.fillStyle = piece.color === 'white' ? '#FFFFFF' : '#000000';
                        ctx.font = '48px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Add shadow for better visibility
                        ctx.strokeStyle = piece.color === 'white' ? '#000000' : '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.strokeText(pieces[piece.color][piece.type], 
                                      x + SQUARE_SIZE/2, y + SQUARE_SIZE/2);
                        ctx.fillText(pieces[piece.color][piece.type], 
                                    x + SQUARE_SIZE/2, y + SQUARE_SIZE/2);
                    }
                }
            }
            
            // Draw coordinates
            ctx.fillStyle = '#444';
            ctx.font = '12px Arial';
            for (let i = 0; i < 8; i++) {
                ctx.fillText(String.fromCharCode(97 + i), i * SQUARE_SIZE + 5, canvas.height - 5);
                ctx.fillText(8 - i, 5, i * SQUARE_SIZE + 15);
            }
        }
        
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || piece.color !== currentPlayer) return [];
            
            const moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    // Forward moves
                    if (board[row + direction] && !board[row + direction][col]) {
                        moves.push({ row: row + direction, col });
                        if (row === startRow && !board[row + 2 * direction][col]) {
                            moves.push({ row: row + 2 * direction, col });
                        }
                    }
                    
                    // Captures
                    [-1, 1].forEach(dc => {
                        if (col + dc >= 0 && col + dc < 8 && row + direction >= 0 && row + direction < 8) {
                            const target = board[row + direction][col + dc];
                            if (target && target.color !== piece.color) {
                                moves.push({ row: row + direction, col: col + dc });
                            }
                        }
                    });
                    break;
                    
                case 'rook':
                    addLinearMoves(moves, row, col, [[-1,0], [1,0], [0,-1], [0,1]]);
                    break;
                    
                case 'bishop':
                    addLinearMoves(moves, row, col, [[-1,-1], [-1,1], [1,-1], [1,1]]);
                    break;
                    
                case 'queen':
                    addLinearMoves(moves, row, col, [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]]);
                    break;
                    
                case 'king':
                    [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]].forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = board[newRow][newCol];
                            if (!target || target.color !== piece.color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    });
                    break;
                    
                case 'knight':
                    [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]].forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = board[newRow][newCol];
                            if (!target || target.color !== piece.color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    });
                    break;
            }
            
            return moves;
        }
        
        function addLinearMoves(moves, row, col, directions) {
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== board[row][col].color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            });
        }
        
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Save move for undo
            moveHistory.push({
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: { ...piece },
                captured: capturedPiece ? { ...capturedPiece } : null
            });
            
            // Handle capture
            if (capturedPiece) {
                if (capturedPiece.color === 'white') {
                    capturedBlack.push(capturedPiece);
                } else {
                    capturedWhite.push(capturedPiece);
                }
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            piece.moved = true;
            
            // Check for pawn promotion
            if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                piece.type = 'queen';
            }
            
            // Switch turns
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            selectedPiece = null;
            
            updateDisplay();
            
            // Check game end
            if (isCheckmate()) {
                endGame(currentPlayer === 'white' ? 'ดำชนะ!' : 'ขาวชนะ!');
            } else if (isStalemate()) {
                endGame('เสมอ!');
            }
            
            // AI move
            if (currentPlayer === 'black' && gameRunning) {
                setTimeout(makeAIMove, 500);
            }
        }
        
        function makeAIMove() {
            const allMoves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === 'black') {
                        const moves = getValidMoves(row, col);
                        moves.forEach(move => {
                            allMoves.push({
                                from: { row, col },
                                to: move,
                                piece,
                                score: evaluateMove(row, col, move.row, move.col)
                            });
                        });
                    }
                }
            }
            
            if (allMoves.length === 0) return;
            
            // Choose move based on difficulty
            let chosenMove;
            if (difficulty === 'easy') {
                chosenMove = allMoves[Math.floor(Math.random() * allMoves.length)];
            } else {
                allMoves.sort((a, b) => b.score - a.score);
                chosenMove = allMoves[0];
            }
            
            makeMove(chosenMove.from.row, chosenMove.from.col, chosenMove.to.row, chosenMove.to.col);
        }
        
        function evaluateMove(fromRow, fromCol, toRow, toCol) {
            let score = Math.random() * 10; // Random element
            
            const piece = board[fromRow][fromCol];
            const target = board[toRow][toCol];
            
            // Prefer captures
            if (target) {
                const pieceValues = { pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 100 };
                score += pieceValues[target.type] * 10;
            }
            
            // Control center
            if (toRow >= 2 && toRow <= 5 && toCol >= 2 && toCol <= 5) {
                score += 5;
            }
            
            return score;
        }
        
        function isCheckmate() {
            // Simplified checkmate detection
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === currentPlayer) {
                        if (getValidMoves(row, col).length > 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        function isStalemate() {
            return false; // Simplified
        }
        
        function endGame(message) {
            gameRunning = false;
            document.getElementById('gameResult').textContent = 'เกมจบ!';
            document.getElementById('gameMessage').textContent = message;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function updateDisplay() {
            document.getElementById('turnIndicator').textContent = 
                currentPlayer === 'white' ? 'ตาของคุณ (ขาว)' : 'ตาของ AI (ดำ)';
            
            document.getElementById('whiteCaptured').textContent = 
                capturedWhite.map(p => pieces.white[p.type]).join(' ');
            document.getElementById('blackCaptured').textContent = 
                capturedBlack.map(p => pieces.black[p.type]).join(' ');
        }
        
        function newGame() {
            initBoard();
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function undoMove() {
            if (moveHistory.length === 0) return;
            
            const lastMove = moveHistory.pop();
            board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
            
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            selectedPiece = null;
            
            // Remove from captured pieces
            if (lastMove.captured) {
                if (lastMove.captured.color === 'white') {
                    capturedBlack.pop();
                } else {
                    capturedWhite.pop();
                }
            }
            
            updateDisplay();
        }
        
        function toggleDifficulty() {
            difficulty = difficulty === 'easy' ? 'hard' : 'easy';
            document.getElementById('difficultyBtn').textContent = 
                difficulty === 'easy' ? 'ง่าย' : 'ยาก';
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard();
            requestAnimationFrame(gameLoop);
        }
        
        // Mouse controls
        canvas.addEventListener('click', (e) => {
            if (!gameRunning || currentPlayer !== 'white') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / SQUARE_SIZE);
            const row = Math.floor(y / SQUARE_SIZE);
            
            if (row < 0 || row >= 8 || col < 0 || col >= 8) return;
            
            if (selectedPiece) {
                const validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                
                if (isValidMove) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                } else {
                    selectedPiece = null;
                }
            } else {
                const piece = board[row][col];
                if (piece && piece.color === 'white') {
                    selectedPiece = { row, col };
                }
            }
        });
        
        // Start game
        initBoard();
        gameLoop();
    </script>
    <!-- ASHURA:shared-js -->
    <script src="./game-optimization.js"></script>
    <!-- ASHURA:gf-config -->
<script>
  window.GF_CONFIG = {
    showPauseOverlay: true,
    autoMuteOnPause: true,
    maxDevicePixelRatio: 1.5,
    resizeDebounceMs: 180,
    autoPauseOnHide: true,
    hints: true,
    debug: false
  };
</script>
<script src="./_assets/game-frame.js"></script>
</body>
</html>