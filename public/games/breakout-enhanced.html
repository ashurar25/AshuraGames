
<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Enhanced - ASHURA Games</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            position: relative;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(16, 185, 129, 0.3);
            padding: 20px;
        }

        canvas {
            border-radius: 15px;
            background: linear-gradient(180deg, #0f0f23 0%, #1a1a2e 100%);
            display: block;
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.3);
        }

        .game-ui {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #10b981;
            display: none;
            z-index: 20;
            color: white;
        }

        .restart-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .controls {
            text-align: center;
            color: #94a3b8;
            font-size: 14px;
            margin-top: 10px;
        }

        .credit {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #10b981;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 15px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-ui">
            <div>üèÜ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score">0</span></div>
            <div>‚ù§Ô∏è ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï: <span id="lives">3</span></div>
            <div>üìä ‡πÄ‡∏•‡πÄ‡∏ß‡∏•: <span id="level">1</span></div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="game-over" id="gameOver">
            <h2 style="color: #ef4444; margin-top: 0;">üéÆ ‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß!</h2>
            <p>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: <span id="finalScore">0</span></p>
            <p>‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: <span id="finalLevel">1</span></p>
            <button class="restart-btn" onclick="startGame()">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
        </div>

        <div class="controls">
            ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå ‡∏´‡∏£‡∏∑‡∏≠ ‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ã‡πâ‡∏≤‡∏¢-‡∏Ç‡∏ß‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏û‡∏î‡πÄ‡∏î‡∏¥‡∏•<br>
            ‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏≠‡∏¥‡∏ê‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ú‡πà‡∏≤‡∏ô‡∏î‡πà‡∏≤‡∏ô!
        </div>
    </div>

    <div class="credit">¬© ASHURA Games</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        let bricks = [];
        let particles = [];

        // ‡πÄ‡∏Å‡∏°‡∏≠‡∏≠‡∏ö‡πÄ‡∏à‡∏Å‡∏ï‡πå
        const paddle = {
            x: canvas.width / 2 - 75,
            y: canvas.height - 30,
            width: 150,
            height: 15,
            speed: 8
        };

        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            speedX: 5,
            speedY: -5,
            maxSpeed: 12
        };

        // ‡∏Ñ‡∏•‡∏≤‡∏™ Particle
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.color = color;
                this.life = 30;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / 30;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ê
        function createBricks() {
            bricks = [];
            const rows = 6 + level;
            const cols = 10;
            const brickWidth = 70;
            const brickHeight = 25;
            const padding = 5;
            const offsetX = (canvas.width - (cols * (brickWidth + padding))) / 2;
            const offsetY = 50;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd'];
                    bricks.push({
                        x: col * (brickWidth + padding) + offsetX,
                        y: row * (brickHeight + padding) + offsetY,
                        width: brickWidth,
                        height: brickHeight,
                        color: colors[row % colors.length],
                        visible: true,
                        points: (rows - row) * 10
                    });
                }
            }
        }

        // ‡∏ß‡∏≤‡∏î‡πÅ‡∏û‡∏î‡πÄ‡∏î‡∏¥‡∏•
        function drawPaddle() {
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#10b981');
            gradient.addColorStop(1, '#059669');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        // ‡∏ß‡∏≤‡∏î‡∏ö‡∏≠‡∏•
        function drawBall() {
            const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, '#10b981');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡πÄ‡∏á‡∏≤
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // ‡∏ß‡∏≤‡∏î‡∏≠‡∏¥‡∏ê
        function drawBricks() {
            bricks.forEach(brick => {
                if (brick.visible) {
                    const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
                    gradient.addColorStop(0, brick.color);
                    gradient.addColorStop(1, '#000000');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                }
            });
        }

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ö‡∏≠‡∏•
        function updateBall() {
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // ‡∏ä‡∏ô‡∏ú‡∏ô‡∏±‡∏á
            if (ball.x <= ball.radius || ball.x >= canvas.width - ball.radius) {
                ball.speedX = -ball.speedX;
            }
            if (ball.y <= ball.radius) {
                ball.speedY = -ball.speedY;
            }

            // ‡∏ä‡∏ô‡πÅ‡∏û‡∏î‡πÄ‡∏î‡∏¥‡∏•
            if (ball.y + ball.radius >= paddle.y &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width &&
                ball.speedY > 0) {
                
                ball.speedY = -ball.speedY;
                
                // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏ô
                const hitPos = (ball.x - paddle.x) / paddle.width;
                ball.speedX = (hitPos - 0.5) * 10;
                
                // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
                const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                if (speed > ball.maxSpeed) {
                    ball.speedX = (ball.speedX / speed) * ball.maxSpeed;
                    ball.speedY = (ball.speedY / speed) * ball.maxSpeed;
                }
            }

            // ‡∏ï‡∏Å‡∏´‡∏•‡πà‡∏ô
            if (ball.y > canvas.height) {
                lives--;
                if (lives <= 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }

            // ‡∏ä‡∏ô‡∏≠‡∏¥‡∏ê
            bricks.forEach(brick => {
                if (brick.visible &&
                    ball.x >= brick.x &&
                    ball.x <= brick.x + brick.width &&
                    ball.y >= brick.y &&
                    ball.y <= brick.y + brick.height) {
                    
                    brick.visible = false;
                    ball.speedY = -ball.speedY;
                    score += brick.points;
                    
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏ô‡∏∏‡∏†‡∏≤‡∏Ñ
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(brick.x + brick.width/2, brick.y + brick.height/2, brick.color));
                    }
                    
                    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡∏ô‡∏∞
                    if (bricks.every(b => !b.visible)) {
                        nextLevel();
                    }
                }
            });
        }

        // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ö‡∏≠‡∏•
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speedX = (Math.random() > 0.5 ? 1 : -1) * 5;
            ball.speedY = -5;
        }

        // ‡∏î‡πà‡∏≤‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        function nextLevel() {
            level++;
            ball.maxSpeed += 0.5;
            createBricks();
            resetBall();
        }

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏≠‡∏ô‡∏∏‡∏†‡∏≤‡∏Ñ
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });
        }

        // ‡∏ß‡∏≤‡∏î‡∏≠‡∏ô‡∏∏‡∏†‡∏≤‡∏Ñ
        function drawParticles() {
            particles.forEach(particle => particle.draw());
        }

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
        }

        // ‡∏à‡∏ö‡πÄ‡∏Å‡∏°
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOver').style.display = 'block';
        }

        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
        function startGame() {
            gameRunning = true;
            score = 0;
            lives = 3;
            level = 1;
            particles = [];

            createBricks();
            resetBall();
            
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        // ‡∏ß‡∏≤‡∏î‡πÄ‡∏Å‡∏°
        function draw() {
            // ‡∏•‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f0f23');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBricks();
            drawPaddle();
            drawBall();
            drawParticles();
        }

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏Å‡∏°
        function update() {
            if (!gameRunning) return;
            
            updateBall();
            updateParticles();
            updateUI();
        }

        // ‡∏•‡∏π‡∏õ‡πÄ‡∏Å‡∏°
        let lastTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;

        function gameLoop(currentTime) {
            if (currentTime - lastTime < frameTime) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastTime = currentTime;

            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
            if (e.key === 'ArrowRight' && paddle.x < canvas.width - paddle.width) {
                paddle.x += paddle.speed;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            paddle.x = mouseX - paddle.width / 2;
            
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x > canvas.width - paddle.width) paddle.x = canvas.width - paddle.width;
        });

        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
        startGame();
        gameLoop(0);
    </script>
</body>
</html>
