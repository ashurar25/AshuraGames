
<!DOCTYPE html>
<html   lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ทลายอิฐ ฉบับพิเศษ - ASHURA Games</title>
    <!-- ASHURA:shared-css -->
    <link rel="stylesheet" href="./game-enhancement.css">
    <link rel="stylesheet" href="./game-optimization.css">
    <link rel="stylesheet" href="./_assets/game-frame.css">

    <link rel="stylesheet" href="game-optimization.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        canvas {
            border: 2px solid #fff;
            border-radius: 10px;
            background: #000;
        }

        .game-info {
            color: white;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }

        .controls {
            color: white;
            margin-top: 15px;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 style="color: white; margin-bottom: 20px;">ทลายอิฐ ฉบับพิเศษ</h1>
        
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="controls">
            <p><strong>Controls:</strong> Use mouse or arrow keys to move paddle</p>
            <button onclick="startGame()">Start Game</button>
            <button onclick="pauseGame()">Pause</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        
        // Paddle
        let paddle = {
            x: canvas.width / 2 - 50,
            y: canvas.height - 30,
            width: 100,
            height: 15,
            speed: 8
        };
        
        // Ball
        let ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            speedX: 4,
            speedY: -4,
            trail: []
        };
        
        // Bricks
        let bricks = [];
        let brickRows = 6;
        let brickCols = 10;
        let brickWidth = 55;
        let brickHeight = 20;
        let brickPadding = 3;
        let brickOffsetTop = 60;
        let brickOffsetLeft = 30;
        
        // Power-ups
        let powerUps = [];
        let activePowerUps = [];
        
        // Particles
        let particles = [];
        
        // Controls
        let keys = {};
        let mouseX = paddle.x;
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left - paddle.width / 2;
        });
        
        function initBricks() {
            bricks = [];
            for (let r = 0; r < brickRows; r++) {
                for (let c = 0; c < brickCols; c++) {
                    let brick = {
                        x: c * (brickWidth + brickPadding) + brickOffsetLeft,
                        y: r * (brickHeight + brickPadding) + brickOffsetTop,
                        width: brickWidth,
                        height: brickHeight,
                        hits: 1,
                        color: `hsl(${r * 60}, 70%, 60%)`,
                        points: (brickRows - r) * 10
                    };
                    
                    // Special bricks
                    if (Math.random() < 0.1) {
                        brick.hits = 2;
                        brick.points *= 2;
                        brick.special = 'tough';
                    } else if (Math.random() < 0.05) {
                        brick.powerUp = Math.random() < 0.5 ? 'multiball' : 'bigpaddle';
                        brick.special = 'powerup';
                    }
                    
                    bricks.push(brick);
                }
            }
        }
        
        function updatePaddle() {
            if (keys['ArrowLeft'] && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
            if (keys['ArrowRight'] && paddle.x < canvas.width - paddle.width) {
                paddle.x += paddle.speed;
            }
            
            // Mouse control
            paddle.x = Math.max(0, Math.min(mouseX, canvas.width - paddle.width));
        }
        
        function updateBall() {
            // Add to trail
            ball.trail.push({x: ball.x, y: ball.y});
            if (ball.trail.length > 10) ball.trail.shift();
            
            ball.x += ball.speedX;
            ball.y += ball.speedY;
            
            // Wall collisions
            if (ball.x <= ball.radius || ball.x >= canvas.width - ball.radius) {
                ball.speedX = -ball.speedX;
                createParticles(ball.x, ball.y, '#fff');
            }
            
            if (ball.y <= ball.radius) {
                ball.speedY = -ball.speedY;
                createParticles(ball.x, ball.y, '#fff');
            }
            
            // Paddle collision
            if (ball.y + ball.radius >= paddle.y && 
                ball.x >= paddle.x && 
                ball.x <= paddle.x + paddle.width &&
                ball.speedY > 0) {
                
                let hitPos = (ball.x - paddle.x) / paddle.width;
                ball.speedX = (hitPos - 0.5) * 8;
                ball.speedY = -Math.abs(ball.speedY);
                createParticles(ball.x, ball.y, '#00ff00');
            }
            
            // Bottom boundary
            if (ball.y > canvas.height) {
                lives--;
                if (lives <= 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }
        }
        
        function checkBrickCollisions() {
            for (let i = bricks.length - 1; i >= 0; i--) {
                let brick = bricks[i];
                
                if (ball.x >= brick.x && 
                    ball.x <= brick.x + brick.width &&
                    ball.y >= brick.y && 
                    ball.y <= brick.y + brick.height) {
                    
                    ball.speedY = -ball.speedY;
                    brick.hits--;
                    
                    if (brick.hits <= 0) {
                        score += brick.points;
                        createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color);
                        
                        if (brick.powerUp) {
                            createPowerUp(brick.x + brick.width/2, brick.y + brick.height/2, brick.powerUp);
                        }
                        
                        bricks.splice(i, 1);
                        
                        if (bricks.length === 0) {
                            nextLevel();
                        }
                    }
                    break;
                }
            }
        }
        
        function createPowerUp(x, y, type) {
            powerUps.push({
                x: x,
                y: y,
                width: 20,
                height: 20,
                speed: 2,
                type: type
            });
        }
        
        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                let powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                
                // Check collision with paddle
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.x + powerUp.width >= paddle.x &&
                    powerUp.x <= paddle.x + paddle.width) {
                    
                    activatePowerUp(powerUp.type);
                    powerUps.splice(i, 1);
                } else if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
        }
        
        function activatePowerUp(type) {
            switch(type) {
                case 'multiball':
                    // Create additional balls
                    for (let i = 0; i < 2; i++) {
                        let newBall = {...ball};
                        newBall.speedX = (Math.random() - 0.5) * 8;
                        newBall.speedY = -Math.abs(newBall.speedY);
                        // This would need multi-ball system implementation
                    }
                    break;
                case 'bigpaddle':
                    paddle.width = Math.min(150, paddle.width * 1.5);
                    setTimeout(() => {
                        paddle.width = 100;
                    }, 10000);
                    break;
            }
        }
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    speedX: (Math.random() - 0.5) * 6,
                    speedY: (Math.random() - 0.5) * 6,
                    life: 30,
                    color: color
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let particle = particles[i];
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ball trail
            for (let i = 0; i < ball.trail.length; i++) {
                let alpha = i / ball.trail.length;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(ball.trail[i].x, ball.trail[i].y, ball.radius * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw ball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw paddle with gradient
            let gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#00ff00');
            gradient.addColorStop(1, '#008800');
            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // Draw bricks
            bricks.forEach(brick => {
                ctx.fillStyle = brick.color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                
                if (brick.special === 'tough') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                } else if (brick.special === 'powerup') {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(brick.x + brick.width/2 - 5, brick.y + brick.height/2 - 5, 10, 10);
                }
            });
            
            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUp.type === 'multiball' ? '#ff6b6b' : '#4ecdc4';
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
            });
            
            // Draw particles
            particles.forEach(particle => {
                let alpha = particle.life / 30;
                ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(particle.x, particle.y, 3, 3);
            });
        }
        
        function gameLoop() {
            if (!gameRunning || gamePaused) return;
            
            updatePaddle();
            updateBall();
            checkBrickCollisions();
            updatePowerUps();
            updateParticles();
            draw();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
        }
        
        function startGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            lives = 3;
            level = 1;
            initBricks();
            resetBall();
            gameLoop();
        }
        
        function pauseGame() {
            gamePaused = !gamePaused;
            if (!gamePaused) gameLoop();
        }
        
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speedX = (Math.random() - 0.5) * 6;
            ball.speedY = -4;
            ball.trail = [];
        }
        
        function nextLevel() {
            level++;
            brickRows = Math.min(8, brickRows + 1);
            ball.speedX *= 1.1;
            ball.speedY *= 1.1;
            initBricks();
            resetBall();
        }
        
        function gameOver() {
            gameRunning = false;
            alert(`Game Over! Final Score: ${score}`);
        }
        
        // Initialize
        draw();
        updateUI();
    </script>
    <!-- ASHURA:shared-js -->
    <script src="./game-optimization.js"></script>
    <!-- ASHURA:gf-config -->
<script>
  window.GF_CONFIG = {
    showPauseOverlay: true,
    autoMuteOnPause: true,
    quality: 'high',
    resizeDebounceMs: 150,
    debug: false
  };
</script>
<script src="./_assets/game-frame.js"></script>
</body>
</html>
