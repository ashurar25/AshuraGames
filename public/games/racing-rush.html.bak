<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Rush - ASHURA Games</title>
    <style>
        body { margin: 0; padding: 0; background: #222; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; margin: 0 auto; background: linear-gradient(to bottom, #87CEEB, #228B22); }
        .ui { position: absolute; top: 10px; left: 10px; color: #fff; font-size: 20px; z-index: 10; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
        .controls { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #fff; text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
    </style>
</head>
<body>
    <div class="ui">
        <div>ความเร็ว: <span id="speed">0</span> km/h</div>
        <div>ระยะทาง: <span id="distance">0</span> m</div>
        <div>คะแนน: <span id="score">0</span></div>
        <div>เหรียญ: <span id="coins_collected">0</span></div>
    </div>
    <div class="controls">
        <div>← → : หลีกเลี่ยง | ↑ ↓ : เร่ง/ลดความเร็ว</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // ตัวแปรเกม
        let car = { 
            x: 375, y: 400, width: 50, height: 80, 
            speed: 0, maxSpeed: 8, acceleration: 0.2, friction: 0.95,
            angle: 0, drift: 0, boostTimer: 0
        };
        let obstacles = [];
        let coins = [];
        let score = 0;
        let distance = 0;
        let gameSpeed = 2;
        let roadOffset = 0;
        let particles = [];
        let coins_collected = 0;

        // รถคันอื่น
        let otherCars = [];
        let lastCarSpawn = 0;

        // คลาสรถอื่น
        class OtherCar {
            constructor() {
                this.width = 45;
                this.height = 75;
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -this.height;
                this.speed = gameSpeed + Math.random() * 3;
                this.color = this.getRandomColor();
            }

            getRandomColor() {
                const colors = ['#ff4444', '#4444ff', '#44ff44', '#ffff44', '#ff44ff', '#44ffff', '#ff8844'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                // วาดรถ
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // วาดหน้าต่าง
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(this.x + 5, this.y + 10, this.width - 10, 20);
                ctx.fillRect(this.x + 5, this.y + 35, this.width - 10, 15);

                // วาดไฟหน้า
                ctx.fillStyle = '#ffff99';
                ctx.fillRect(this.x + 5, this.y + this.height - 10, 12, 8);
                ctx.fillRect(this.x + this.width - 17, this.y + this.height - 10, 12, 8);

                // วาดล้อ
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - 3, this.y + 15, 8, 12);
                ctx.fillRect(this.x + this.width - 5, this.y + 15, 8, 12);
                ctx.fillRect(this.x - 3, this.y + this.height - 25, 8, 12);
                ctx.fillRect(this.x + this.width - 5, this.y + this.height - 25, 8, 12);
            }
        }

        // คลาสอนุภาคควัน
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = Math.random() * 2 + 1;
                this.size = Math.random() * 5 + 2;
                this.alpha = 1;
                this.decay = 0.02;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha -= this.decay;
                this.size *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = '#666';
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }

        // วาดถนน
        function drawRoad() {
            // พื้นหลัง
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.3, '#98FB98');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ถนน
            ctx.fillStyle = '#444';
            ctx.fillRect(canvas.width * 0.2, 0, canvas.width * 0.6, canvas.height);

            // ขอบถนน
            ctx.fillStyle = '#fff';
            ctx.fillRect(canvas.width * 0.2 - 5, 0, 5, canvas.height);
            ctx.fillRect(canvas.width * 0.8, 0, 5, canvas.height);

            // เส้นกลางถนน
            ctx.fillStyle = '#ffff00';
            const lineHeight = 30;
            const lineGap = 20;
            roadOffset += gameSpeed;
            if (roadOffset > lineHeight + lineGap) roadOffset = 0;

            for (let y = -roadOffset; y < canvas.height; y += lineHeight + lineGap) {
                ctx.fillRect(canvas.width / 2 - 2, y, 4, lineHeight);
            }

            // ต้นไม้ข้างทาง
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 10; i++) {
                const treeY = (i * 80 - roadOffset) % canvas.height;
                // ต้นไม้ซ้าย
                ctx.fillRect(50, treeY, 20, 30);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(55, treeY + 25, 10, 15);
                ctx.fillStyle = '#228B22';

                // ต้นไม้ขวา
                ctx.fillRect(canvas.width - 70, treeY, 20, 30);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(canvas.width - 65, treeY + 25, 10, 15);
                ctx.fillStyle = '#228B22';
            }
        }

        // วาดรถผู้เล่น
        function drawPlayerCar() {
            ctx.save();
            ctx.translate(car.x + car.width / 2, car.y + car.height / 2);
            ctx.rotate(car.angle);

            // เงารถ
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(-car.width / 2, -car.height / 2 + 8, car.width, car.height - 5);

            // ตัวรถ
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);

            // รายละเอียดรถ
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-car.width / 2 + 5, -car.height / 2 + 15, car.width - 10, 25);

            // ไฟหน้า
            ctx.fillStyle = '#ffff99';
            ctx.fillRect(-car.width / 2 + 5, -car.height / 2, 12, 8);
            ctx.fillRect(car.width / 2 - 17, -car.height / 2, 12, 8);

            // กันชน
            ctx.fillStyle = '#ccc';
            ctx.fillRect(-car.width / 2, -car.height / 2 - 3, car.width, 3);

            // ล้อ
            ctx.fillStyle = '#333';
            ctx.fillRect(-car.width / 2 - 3, -car.height / 2 + 15, 8, 12);
            ctx.fillRect(car.width / 2 - 5, -car.height / 2 + 15, 8, 12);
            ctx.fillRect(-car.width / 2 - 3, car.height / 2 - 25, 8, 12);
            ctx.fillRect(car.width / 2 - 5, car.height / 2 - 25, 8, 12);

            // ไฟท้าย
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(-car.width / 2 + 5, car.height / 2 - 8, 8, 6);
            ctx.fillRect(car.width / 2 - 13, car.height / 2 - 8, 8, 6);

            ctx.restore();
        }

        // ตรวจสอบการชน
        function checkCollisions() {
            const carRect = {
                x: car.x,
                y: car.y,
                width: car.width,
                height: car.height
            };

            for (let i = 0; i < otherCars.length; i++) {
                const other = otherCars[i];
                const otherRect = {
                    x: other.x,
                    y: other.y,
                    width: other.width,
                    height: other.height
                };

                if (isColliding(carRect, otherRect)) {
                    gameSpeed = 0;
                    if (confirm('อุบัติเหตุ! คะแนน: ' + score + '\nคลิก OK เพื่อเล่นใหม่')) {
                        resetGame();
                    }
                    return true;
                }
            }
            return false;
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }


        // รีเซ็ตเกม
        function resetGame() {
            gameSpeed = 2;
            score = 0;
            distance = 0;
            car.x = canvas.width / 2 - car.width / 2;
            car.y = canvas.height - 120;
            car.speed = 0;
            car.angle = 0;
            car.drift = 0;
            otherCars = [];
            particles = [];
            coins_collected = 0;
        }

        // อัปเดตเกม
        function update() {
            // การเคลื่อนไหวของรถ
            let acceleration = 0;
            if (keys['ArrowUp']) {
                acceleration += car.acceleration;
            }
            if (keys['ArrowDown']) {
                acceleration -= car.acceleration * 0.5; // ลดความเร็ว
            }

            car.speed += acceleration;
            car.speed *= car.friction; // ใช้ friction เพื่อลดความเร็ว
            car.speed = Math.max(-car.maxSpeed * 0.5, Math.min(car.maxSpeed, car.speed)); // จำกัดความเร็ว

            // การควบคุมเลี้ยว
            let turn = 0;
            if (keys['ArrowLeft']) {
                turn = -0.1;
            }
            if (keys['ArrowRight']) {
                turn = 0.1;
            }

            car.angle += turn - car.drift * 0.05; // การเลี้ยวและการดริฟท์
            car.drift *= 0.9; // ลดค่า drift

            // การเคลื่อนที่จริง
            const moveX = car.speed * Math.sin(car.angle);
            const moveY = car.speed * Math.cos(car.angle);

            car.x += moveX;
            car.y -= moveY; // ตามแกน Y ปกติ

            // จำกัดขอบเขตถนน
            const roadLeft = canvas.width * 0.2;
            const roadRight = canvas.width * 0.8;
            const carHalfWidth = car.width / 2;

            if (car.x < roadLeft) {
                car.x = roadLeft;
                car.drift = 0.1; // เกิดการดริฟท์เมื่อชนขอบ
            } else if (car.x > roadRight - car.width) {
                car.x = roadRight - car.width;
                car.drift = -0.1; // เกิดการดริฟท์เมื่อชนขอบ
            }

            // ปรับปรุง gameSpeed ตามความเร็วรถ
            gameSpeed = car.speed * 5; // ปรับ gameSpeed ให้สัมพันธ์กับความเร็วรถ
            gameSpeed = Math.max(1, Math.min(8, gameSpeed));


            // สร้างรถคันอื่น
            if (Date.now() - lastCarSpawn > 2000 - gameSpeed * 200) {
                otherCars.push(new OtherCar());
                lastCarSpawn = Date.now();
            }

            // อัปเดตรถคันอื่น
            otherCars = otherCars.filter(otherCar => {
                otherCar.update();
                return otherCar.y < canvas.height + 100;
            });

            // อัปเดตอนุภาค
            particles = particles.filter(particle => {
                particle.update();
                return particle.alpha > 0;
            });

            // สร้างอนุภาคควัน
            if (Math.random() < 0.3) {
                particles.push(new Particle(
                    car.x + car.width / 2 + (Math.random() - 0.5) * 10,
                    car.y + car.height
                ));
            }

            // อัปเดตคะแนนและระยะทาง
            distance += gameSpeed;
            score = Math.floor(distance / 10);

            // ตรวจสอบการชน
            checkCollisions();
        }

        // วาดเกม
        function draw() {
            drawRoad();

            // วาดรถคันอื่น
            otherCars.forEach(otherCar => otherCar.draw());

            // วาดอนุภาค
            particles.forEach(particle => particle.draw());

            drawPlayerCar();

            // อัปเดต UI
            document.getElementById('speed').textContent = Math.floor(car.speed * 50); // แสดงความเร็วที่คำนวณได้
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('score').textContent = score;
            document.getElementById('coins_collected').textContent = coins_collected;
        }

        let lastTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;

        // ลูปเกม
        function gameLoop(currentTime) {
            // Frame rate control
            if (currentTime - lastTime < frameTime) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastTime = currentTime;

            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Touch controls
        let touchControls = {
            touching: false,
            startX: 0,
            startY: 0
        };

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchControls.touching = true;
            touchControls.startX = touch.clientX - rect.left;
            touchControls.startY = touch.clientY - rect.top;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchControls.touching) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const currentX = touch.clientX - rect.left;
            const currentY = touch.clientY - rect.top;

            // Control car position based on touch
            const roadLeft = canvas.width * 0.2;
            const roadRight = canvas.width * 0.8;
            const roadWidth = roadRight - roadLeft;

            if (currentX > roadLeft && currentX < roadRight) {
                // Adjust car's x position based on touch x
                car.x = currentX - car.width / 2;
                // Limit car's x position within road boundaries
                car.x = Math.max(roadLeft, Math.min(roadRight - car.width, car.x));
            }

            // Control speed based on vertical movement
            const deltaY = currentY - touchControls.startY;
            if (deltaY < -20) {
                // Touch moved up - accelerate
                if (car.speed < car.maxSpeed) {
                    car.speed += car.acceleration;
                }
            } else if (deltaY > 20) {
                // Touch moved down - brake
                if (car.speed > -car.maxSpeed * 0.5) { // Allow reverse slightly
                    car.speed -= car.acceleration;
                }
            }
            touchControls.startY = currentY; // Update startY for continuous control
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchControls.touching = false;
            // Reset drift when touch ends
            car.drift = 0; 
        });

        // เริ่มเกม
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>