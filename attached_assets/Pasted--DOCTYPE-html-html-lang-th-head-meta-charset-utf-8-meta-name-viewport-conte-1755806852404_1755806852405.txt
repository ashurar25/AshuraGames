<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Slither-like Snake (HTML5)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0f1a; font-family: ui-sans-serif, system-ui, -apple-system; }
    #ui { position: fixed; inset: 0; pointer-events: none; display: grid; }
    .hud { align-self: start; justify-self: start; margin: 12px; padding: 10px 12px; background: rgba(255,255,255,.06); color:#e6ecff; border:1px solid rgba(255,255,255,.08); border-radius: 14px; backdrop-filter: blur(6px); }
    .hud h1 { margin: 0 0 6px 0; font-size: 14px; letter-spacing:.4px; font-weight: 700; color:#bcd1ff; }
    .hud p { margin: 2px 0; font-size: 12px; opacity:.9 }
    .center { align-self: center; justify-self: center; text-align:center; pointer-events: auto; }
    .btn { display:inline-block; margin-top:10px; padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.08); color:#e6ecff; cursor:pointer; user-select:none; }
    .toast { position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%); color:#bcd1ff; font-size: 12px; opacity:.8 }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="hud" id="hud">
      <h1>üêç Slither-like</h1>
      <p>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß: <span id="len">0</span></p>
      <p>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score">0</span></p>
      <p>FPS: <span id="fps">0</span></p>
    </div>
    <div class="center" id="menu">
      <div class="hud" style="pointer-events:auto;">
        <h1>‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô</h1>
        <p>‡πÄ‡∏°‡∏≤‡∏™‡πå/‡∏ô‡∏¥‡πâ‡∏ß: ‡πÄ‡∏•‡πá‡∏á‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á ‚Ä¢ WASD/‡∏•‡∏π‡∏Å‡∏®‡∏£: ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö ‚Ä¢ Space: ‡πÄ‡∏£‡πà‡∏á (‡πÄ‡∏™‡∏µ‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß)</p>
        <div class="btn" id="startBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</div>
      </div>
    </div>
    <div class="toast">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏¢‡∏≤‡∏¢‡∏à‡∏∑‡πâ‡∏ô ‚Ä¢ single-player demo</div>
  </div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const rnd = (a=1,b=0)=>Math.random()*(a-b)+b;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const ui = {
    len: document.getElementById('len'),
    score: document.getElementById('score'),
    fps: document.getElementById('fps'),
    menu: document.getElementById('menu'),
    startBtn: document.getElementById('startBtn')
  };

  const world = { size: 6000 }; // square world
  let last = 0, fps = 0;

  const input = {
    mouse: { x: 0, y: 0, down: false },
    keys: {},
    touch: false
  };

  // Resize
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
  }
  window.addEventListener('resize', resize);
  resize();

  // Camera
  const cam = { x: 0, y: 0, zoom: 1 };

  // Food pellets
  const pellets = [];
  const PELLET_COUNT = 800;
  function spawnPellet(x=rnd(world.size), y=rnd(world.size), val=Math.floor(rnd(4,1))){
    pellets.push({x,y,val, t:rnd(TAU)});
  }

  // Snake
  const snake = {
    x: world.size/2,
    y: world.size/2,
    angle: 0,
    speed: 2.1,
    maxSpeed: 3.2,
    turnSpeed: 0.08,
    radius: 11,
    length: 50, // target number of points (body length proxy)
    trail: [], // points following the head
    score: 0,
    alive: false,
    boost: false,
  };

  function reset(){
    snake.x = rnd(world.size*0.6, world.size*0.4);
    snake.y = rnd(world.size*0.6, world.size*0.4);
    snake.angle = rnd(TAU);
    snake.speed = 2.1;
    snake.length = 50;
    snake.trail.length = 0;
    snake.score = 0;
    snake.alive = true;
    pellets.length = 0;
    for(let i=0;i<PELLET_COUNT;i++) spawnPellet(rnd(world.size), rnd(world.size));
  }

  // Input handlers
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    input.mouse.x = (e.clientX - rect.left) * DPR;
    input.mouse.y = (e.clientY - rect.top) * DPR;
  });
  window.addEventListener('mousedown', ()=> input.mouse.down = true);
  window.addEventListener('mouseup', ()=> input.mouse.down = false);
  window.addEventListener('keydown', e=> input.keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e=> input.keys[e.key.toLowerCase()] = false);

  // Touch => treat as mouse
  canvas.addEventListener('touchstart', (e)=>{
    input.touch = true; input.mouse.down = true;
    const t=e.touches[0];
    const rect=canvas.getBoundingClientRect();
    input.mouse.x = (t.clientX-rect.left)*DPR;
    input.mouse.y = (t.clientY-rect.top)*DPR;
  }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{
    const t=e.touches[0]; if(!t) return;
    const rect=canvas.getBoundingClientRect();
    input.mouse.x = (t.clientX-rect.left)*DPR;
    input.mouse.y = (t.clientY-rect.top)*DPR;
  }, {passive:true});
  canvas.addEventListener('touchend', ()=>{ input.mouse.down=false; input.touch=false; }, {passive:true});

  // Helpers
  function wrap(v, max){
    if(v<0) return v+max; if(v>=max) return v-max; return v;
  }

  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  // Game update
  function update(dt){
    if(!snake.alive) return;

    // Controls ‚Üí desired angle
    const cx = canvas.width/2, cy = canvas.height/2;
    const dirKeys = (input.keys['arrowup']||input.keys['w']? {y:-1}: {y:0});
    const dirKeys2 = (input.keys['arrowdown']||input.keys['s']? 1:0) - (input.keys['arrowup']||input.keys['w']?1:0);
    let desiredAngle = snake.angle;

    if(input.touch || input.mouse.x||input.mouse.y){
      const dx = input.mouse.x - cx, dy = input.mouse.y - cy;
      if(dx*dx+dy*dy > 200) desiredAngle = Math.atan2(dy, dx);
    }

    // keyboard left/right
    const steer = (input.keys['arrowleft']||input.keys['a']? -1:0) + (input.keys['arrowright']||input.keys['d']? 1:0);
    if(steer) desiredAngle = snake.angle + steer * snake.turnSpeed*2.2;

    // smooth turn
    let da = ((desiredAngle - snake.angle + Math.PI*3) % TAU) - Math.PI;
    snake.angle = snake.angle + clamp(da, -snake.turnSpeed, snake.turnSpeed);

    // Boost
    snake.boost = input.mouse.down || input.keys[' '];
    const baseSpeed = snake.maxSpeed * (snake.boost? 1.0 : 0.7);
    snake.speed = lerp(snake.speed, baseSpeed, 0.15);

    // consume length when boosting
    if(snake.boost && snake.length>30){
      if(Math.random()<0.5){
        // drop a pellet behind when boosting
        const bx = wrap(snake.x - Math.cos(snake.angle)*20, world.size);
        const by = wrap(snake.y - Math.sin(snake.angle)*20, world.size);
        spawnPellet(bx,by,2);
      }
      snake.length -= 0.10; // slow drain
    }

    // Move head
    snake.x = wrap(snake.x + Math.cos(snake.angle) * snake.speed*2.2, world.size);
    snake.y = wrap(snake.y + Math.sin(snake.angle) * snake.speed*2.2, world.size);

    // Push head point to trail
    snake.trail.unshift({x:snake.x, y:snake.y});
    // target trail length proportional to logical length (scaled)
    const targetTrail = Math.floor(snake.length*2.2);
    while(snake.trail.length > targetTrail) snake.trail.pop();

    // Self-collision (head vs body after some offset)
    const headR = snake.radius*0.75;
    for(let i=20;i<snake.trail.length;i+=2){
      if(dist2(snake.x,snake.y, snake.trail[i].x, snake.trail[i].y) < (headR*headR)){
        snake.alive = false; break;
      }
    }

    // Eat pellets
    for(let i=pellets.length-1;i>=0;i--){
      const p = pellets[i];
      const rr = (snake.radius+6);
      if(dist2(snake.x,snake.y,p.x,p.y) < rr*rr){
        pellets.splice(i,1);
        snake.length += 1.5 * p.val;
        snake.score += 10 * p.val;
        // respawn somewhere else to keep density
        spawnPellet();
      }
    }

    // Camera follows with slight lag + dynamic zoom
    cam.x = lerp(cam.x, snake.x, 0.12);
    cam.y = lerp(cam.y, snake.y, 0.12);
    const targetZoom = clamp(1.5 - (snake.length/300), 0.6, 1.2);
    cam.zoom = lerp(cam.zoom, targetZoom, 0.05);

    // HUD
    ui.len.textContent = Math.floor(snake.length).toString();
    ui.score.textContent = snake.score.toString();
  }

  // Rendering
  function render(){
    ctx.save();
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // Camera transform
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(cam.zoom * DPR, cam.zoom * DPR);
    ctx.translate(-cam.x, -cam.y);

    // --- Background grid
    const grid = 80;
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(140,160,210,0.08)';
    const startX = Math.floor((cam.x - canvas.width/2/(cam.zoom*DPR)) / grid) * grid - grid*2;
    const endX = startX + Math.ceil(canvas.width/(cam.zoom*DPR)) + grid*4;
    const startY = Math.floor((cam.y - canvas.height/2/(cam.zoom*DPR)) / grid) * grid - grid*2;
    const endY = startY + Math.ceil(canvas.height/(cam.zoom*DPR)) + grid*4;
    ctx.beginPath();
    for(let x=startX; x<startX+endX; x+=grid){ ctx.moveTo(x, startY); ctx.lineTo(x, startY+endY); }
    for(let y=startY; y<startY+endY; y+=grid){ ctx.moveTo(startX, y); ctx.lineTo(startX+endX, y); }
    ctx.stroke();

    // World border (wrap visualized as faint square)
    ctx.strokeStyle = 'rgba(200,220,255,0.06)';
    ctx.lineWidth = 6;
    ctx.strokeRect(0,0,world.size, world.size);

    // Pellets
    for(const p of pellets){
      const pulse = 0.5 + 0.5*Math.sin(perfNow*0.003 + p.t);
      const r = 3 + 1.5*pulse + p.val*0.6;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(125,200,255,0.85)';
      ctx.arc(p.x, p.y, r, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.arc(p.x, p.y, r*0.5, 0, TAU);
      ctx.fill();
    }

    // Snake body - draw as rounded segments along trail
    if(snake.trail.length>1){
      for(let i=snake.trail.length-1;i>0;i--){
        const t = i/snake.trail.length;
        const sR = lerp(snake.radius*0.35, snake.radius, 1-t);
        const seg = snake.trail[i];
        ctx.beginPath();
        ctx.fillStyle = `rgba(${Math.floor(70+120*(1-t))}, ${Math.floor(180-40*t)}, ${Math.floor(255-120*t)}, ${0.9})`;
        ctx.arc(seg.x, seg.y, sR, 0, TAU);
        ctx.fill();
      }
    }

    // Snake head
    ctx.beginPath();
    ctx.fillStyle = '#9fd1ff';
    ctx.arc(snake.x, snake.y, snake.radius, 0, TAU);
    ctx.fill();

    // Eyes
    const ex = Math.cos(snake.angle), ey = Math.sin(snake.angle);
    const eyeOff = 5.5, eyeR = 2.6;
    ctx.beginPath(); ctx.fillStyle = '#0b0f1a';
    ctx.arc(snake.x + ex*eyeOff - ey*3, snake.y + ey*eyeOff + ex*3, eyeR, 0, TAU);
    ctx.arc(snake.x + ex*eyeOff + ey*3, snake.y + ey*eyeOff - ex*3, eyeR, 0, TAU);
    ctx.fill();

    ctx.restore();
  }

  // Loop
  let perfNow = 0, accum = 0;
  function loop(ts){
    perfNow = ts;
    if(!last) last = ts;
    const dt = Math.min(33, ts - last); // clamp delta
    last = ts;
    accum = lerp(accum, dt, 0.15);
    fps = Math.round(1000/accum);
    ui.fps.textContent = fps.toString();

    update(dt/16.67);
    render();
    requestAnimationFrame(loop);
  }

  // Start button
  ui.startBtn.addEventListener('click', ()=>{ ui.menu.style.display='none'; reset(); });

  // Start rendering immediately; gameplay begins after reset()
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
